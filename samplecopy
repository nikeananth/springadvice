import java.util.Map;
import java.util.HashMap;
import java.util.Map.Entry;
import java.lang.reflect.Field;

public class ObjectCopyUtil {

    // (Other methods remain unchanged)

    private static <T, U> Map<String, String> createFieldMappingsForClass(Class<T> sourceClass, Class<U> targetClass) {
        if (sourceClass == Employee.class && targetClass == EmployeeV2.class) {
            return Map.of(
                    "name", "employeeName",
                    "employeeId", "id",
                    "salary", "annualSalary",
                    "links", "contactLinks",
                    "address", "employeeAddress",
                    "dschema", "dschema"
            );
        } else if (sourceClass == Address.class && targetClass == AddressV2.class) {
            return Map.of(
                    "street", "street",
                    "city", "city",
                    "zipCode", "zipCode",
                    "location", "location"  // Add this mapping for the Location field
            );
        } else if (sourceClass == Location.class && targetClass == LocationV2.class) {
            return Map.of(
                    "latitude", "latitude",
                    "longitude", "longitude",
                    "datalink", "datalink"  // Add this mapping for the datalink field
            );
        }

        return Map.of();
    }

    // Modify the copyFields method to handle nested objects, including the new datalink field
    public static <T, U> void copyFields(T source, U target, Map<String, String> fieldMappings) {
        Class<?> sourceClass = source.getClass();
        Class<?> targetClass = target.getClass();

        for (Map.Entry<String, String> entry : fieldMappings.entrySet()) {
            String sourceFieldName = entry.getKey();
            String targetFieldName = entry.getValue();

            try {
                Field sourceField = sourceClass.getDeclaredField(sourceFieldName);
                Field targetField = targetClass.getDeclaredField(targetFieldName);
                sourceField.setAccessible(true);
                targetField.setAccessible(true);

                Object value = sourceField.get(source);

                // Handle specific fields
                if (sourceFieldName.equals("datalink")) {
                    // Assuming datalink is a Map, perform a deep copy of the Map
                    Map<Object, Object> originalMap = (Map<Object, Object>) value;
                    Map<Object, Object> copiedMap = deepCopyMap(originalMap);
                    targetField.set(target, copiedMap);
                } else if (value != null && !isPrimitiveOrWrapper(value.getClass())) {
                    // Handle nested objects recursively
                    Object mappedObject = mapNestedObject(value, targetField.getType());
                    targetField.set(target, mappedObject);
                } else {
                    targetField.set(target, value);
                }
            } catch (NoSuchFieldException | IllegalAccessException e) {
                e.printStackTrace(); // Handle or log the exception as needed
            }
        }
    }

    // Deep copy for Map
    private static <K, V> Map<K, V> deepCopyMap(Map<K, V> original) {
        Map<K, V> copy = new HashMap<>();
        for (Entry<K, V> entry : original.entrySet()) {
            K key = entry.getKey();
            V value = entry.getValue();
            copy.put(key, value);
        }
        return copy;
    }

    // (Other methods remain unchanged)
}
