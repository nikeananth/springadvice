import java.util.Map;
import java.util.HashMap;
import java.util.Map.Entry;
import java.lang.reflect.Field;

public class ObjectCopyUtil {

    // (Other methods remain unchanged)

    private static <T, U> Map<String, String> createFieldMappingsForClass(Class<T> sourceClass, Class<U> targetClass) {
        if (sourceClass == Employee.class && targetClass == EmployeeV2.class) {
            return Map.of(
                    "name", "employeeName",
                    "employeeId", "id",
                    "salary", "annualSalary",
                    "links", "contactLinks",
                    "address", "employeeAddress",
                    "dschema", "dschema"
            );
        } else if (sourceClass == Address.class && targetClass == AddressV2.class) {
            return Map.of(
                    "street", "street",
                    "city", "city",
                    "zipCode", "zipCode",
                    "location", "location"  // Add this mapping for the Location field
            );
        } else if (sourceClass == Location.class && targetClass == LocationV2.class) {
            return Map.of(
                    "latitude", "latitude",
                    "longitude", "longitude",
                    "datalink", "datalink"  // Add this mapping for the datalink field
            );
        }

        return Map.of();
    }

    // Modify the copyFields method to handle nested objects, including the new datalink field
    public static <T, U> void copyFields(T source, U target, Map<String, String> fieldMappings) {
        Class<?> sourceClass = source.getClass();
        Class<?> targetClass = target.getClass();

        for (Map.Entry<String, String> entry : fieldMappings.entrySet()) {
            String sourceFieldName = entry.getKey();
            String targetFieldName = entry.getValue();

            try {
                Field sourceField = sourceClass.getDeclaredField(sourceFieldName);
                Field targetField = targetClass.getDeclaredField(targetFieldName);
                sourceField.setAccessible(true);
                targetField.setAccessible(true);

                Object value = sourceField.get(source);

                // Handle specific fields
                if (sourceFieldName.equals("datalink")) {
                    // Perform a deep copy for the datalink field
                    Object copiedDatalink = deepCopyObject(value);
                    targetField.set(target, copiedDatalink);
                } else if (value != null && !isPrimitiveOrWrapper(value.getClass())) {
                    // Handle nested objects recursively
                    Object mappedObject = mapNestedObject(value, targetField.getType());
                    targetField.set(target, mappedObject);
                } else {
                    targetField.set(target, value);
                }
            } catch (NoSuchFieldException | IllegalAccessException e) {
                e.printStackTrace(); // Handle or log the exception as needed
            }
        }
    }

    // Recursive deep copy for objects
    private static Object deepCopyObject(Object original) {
        if (original == null) {
            return null;
        }

        if (original instanceof Map) {
            // Deep copy for Map
            return deepCopyMap((Map<?, ?>) original);
        } else if (original instanceof Iterable) {
            // Deep copy for Iterable (e.g., List, Set)
            return deepCopyIterable((Iterable<?>) original);
        } else if (original.getClass().isArray()) {
            // Deep copy for arrays
            return deepCopyArray(original);
        } else {
            // Assuming it's a simple object (not a nested structure), return a reference copy
            return original;
        }
    }

    // Deep copy for Map
    private static <K, V> Map<K, V> deepCopyMap(Map<K, V> original) {
        Map<K, V> copy = new HashMap<>();
        for (Entry<K, V> entry : original.entrySet()) {
            K key = entry.getKey();
            V value = entry.getValue();
            copy.put(key, (V) deepCopyObject(value));
        }
        return copy;
    }

    // Deep copy for Iterable
    private static Iterable<?> deepCopyIterable(Iterable<?> original) {
        // Assuming it's a collection (e.g., List, Set)
        // You may need to handle other types of Iterable as needed
        // Here, we'll create a new ArrayList for simplicity
        List<Object> copy = new ArrayList<>();
        for (Object item : original) {
            copy.add(deepCopyObject(item));
        }
        return copy;
    }

    // Deep copy for arrays
    private static Object deepCopyArray(Object original) {
        int length = Array.getLength(original);
        Object copy = Array.newInstance(original.getClass().getComponentType(), length);
        for (int i = 0; i < length; i++) {
            Array.set(copy, i, deepCopyObject(Array.get(original, i)));
        }
        return copy;
    }

    // (Other methods remain unchanged)
}
